git init - инициализация папки
git status - проверка статуса
git add <file.txt> добавление файла в проект
git rm --cached <file.txt> - отменяет предыдущую команду (добавление файла в проект)
git commit -m "added commit" - создаём коммит
git log - история коммитов 
git config user.name artur - меняем имя пользователя создающего коммиты
git config user.email - меняем email юзера
git blame <file.txt> - узнаём кто сделал коммит
git clone <url> - создаём клон
git show 9d947s4k - показывает изменения указанного коммита
git rm uslesssfile.txt - удаляем файл из системы и из коммита (уточнить?)
git rm cached local-settings.txt - убирает файл из коммита
git fetch - достаёт коммит, но не мерджит автоматически
git pull - достаёт коммит, но и мерджит автоматически
git fetch origin --prune - посмотреть что удалилось на git
git config --global alias.logg log --pretty... - создаём алиас (logg- имя алиаса, log --pretty... - команда)
git checkout --file.txt - !Worning(диструктивная команда) затирает локальные изменения;
<<<<<<<<<<<<<<------------>>>>>>>>>>>>>>>>

cd ./ - переход по папкам;
ls - выводит содержимое текущей папки;
cat <file.txt> - выводит содержимое файла;

<<<<<<<<<<<<<<-----branch------->>>>>>>>>>>>>>>>

git branch <user> - создать ветку user
git checkout master - перейти на ветку master
git branch - посмотреть ветки (-a -all, -a -vv - все ветки и удаленные и локальние)
git checkout -b <hotfix> - создаём и сразу переходим на ветку hotfix
git push -u origin <new_branch> - запушить локальную ветру на удалённый репозиторий ( <-u> - с провами хозяина)
git branch -d <v2> - удаление локальной ветки
git push origin --delete <v2> - удаление ветки на сервере (при необходимости можно востановить)
git fetch origin --prune - если на сервере какую-то ветку удалили и мы хотим увидить эту синхронизацию у себя (но в нашей локации эта ветка может остаться, и чтобы мы удалили её локально нужно сделать команду которую описал на 2 комманды выше)
git reflog - !показывает гда был HEAD до этого (для того чтобы отследить, с целью востановить, даже удаленные ветки и коммиты)
git checkout -b <user> 9d34b2q - восстановить удалённую ветку (git push -u origin <user> - ветка снова на месте)
//после можно использовать  git checkout -b v2, git push -u origin v2 - всё, ветка вернулась на сервер
// когда на сервере(в проекте) кто-то создал новую ветку, а мы сделали очередной pull - мы стянули эту ветку себе, но git нам её показывать не будет(пока мы его не попросим)

// HEAD - текущее состояние системы, то на каком коммите HEAD находтся;
git reset HEAD --<file.txt> -(тоже диструктивная команда, но не такая дистр. как checkout) переносит HEAD;
// мы в безопасности когда сделали коммит!)
git show <1ed3as5> - покажет изменения этого коммита
git log --pretty=oneline - (git log), но в виде списка коммитов
git log --pretty=oneline - аналогично предыдущему + он короче (7символов в названии коммита)
git log --pretty=oneline -5 --graph - красивенный график коммитов ми-ми-ми;)
git log --pretty=format: '%h	(%h - хеш коммита, %s - месседж коммита, <%an> - имя того кто делал коммит
git log --pretty=format: "%Cred%h%Creset %C(bold blue)<%an>%Creset"%C(#a06a98)%d%C(reser) - график как у Ю.Б.
git config --global alias.logg "log --pretty=oneline --abbrev-commit -5 --graph" - создалл таким образом alias с названием logg для удобства
git config --get-regexp alias - список всех alias-ов

git checkout commit 4v21a8r - перейти к данному коммиту
git stash - вернуться к нынешнему коммиту не внося никаких изменений
git reset --hard <tag/branch/commit id> - откатит вас (переместит HEAD) на указанный коммит (W! диструктивная команда)